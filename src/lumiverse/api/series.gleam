import gleam/dynamic
import gleam/dynamic/decode
import gleam/http
import gleam/http/request
import gleam/int
import gleam/json
import gleam/option
import gleam/result
import lumiverse/api/account
import lumiverse/api/api
import plinth/javascript/date
import rsvp

pub type Series {
  Series(
    id: Int,
    name: String,
    localized_name: String,
    created: date.Date,
    last_chapter_added: date.Date,
    pages: Int,
    pages_read: Int,
    metadata: option.Option(Metadata),
  )
}

pub type Details {
  Details(
    chapters: List(Chapter),
    volumes: List(Volume),
    specials: List(Chapter),
  )
}

pub fn details_decoder() {
  use chapters <- decode.field("chapters", decode.list(chapter_decoder()))
  use volumes <- decode.field("volumes", decode.list(volume_decoder()))
  use specials <- decode.field("specials", decode.list(chapter_decoder()))
  decode.success(Details(chapters:, volumes:, specials:))
}

pub type Volume {
  Volume(
    id: Int,
    name: String,
    max_number: Int,
    chapters: List(Chapter),
    pages: Int,
    pages_read: Int,
  )
}

pub fn volume_decoder() {
  use id <- decode.field("id", decode.int)
  use name <- decode.field("name", decode.string)
  use max_number <- decode.field("maxNumber", decode.int)
  use chapters <- decode.field("chapters", decode.list(chapter_decoder()))
  use pages <- decode.field("pages", decode.int)
  use pages_read <- decode.field("pagesRead", decode.int)
  decode.success(Volume(id:, name:, max_number:, chapters:, pages:, pages_read:))
}

pub type Chapter {
  Chapter(
    id: Int,
    title: String,
    sort_order: Float,
    pages: Int,
    pages_read: Int,
  )
}

pub fn chapter_decoder() {
  use id <- decode.field("id", decode.int)
  use title <- decode.field("title", decode.string)
  use sort_order <- decode.field("sortOrder", decode.float)
  use pages <- decode.field("pages", decode.int)
  use pages_read <- decode.field("pagesRead", decode.int)
  decode.success(Chapter(id:, title:, sort_order:, pages:, pages_read:))
}

pub type SeriesMinimal {
  SeriesMinimal(
    id: Int,
    name: String,
    localized_name: String,
    created: date.Date,
  )
}

pub fn minimal_decoder() {
  use id <- decode.field("id", decode.int)
  use name <- decode.field("name", decode.string)
  use localized_name <- decode.field("localizedName", decode.string)
  use created <- decode.field("created", date_decoder())
  decode.success(SeriesMinimal(id:, name:, localized_name:, created:))
}

pub fn recently_updated_decoder() {
  use id <- decode.field("seriesId", decode.int)
  use name <- decode.field("seriesName", decode.string)
  use created <- decode.field("created", date_decoder())
  decode.success(SeriesMinimal(id:, name:, localized_name: "", created:))
}

// this was generated by gemini
// to update metadata, we have to send everything.
pub type Metadata {
  Metadata(
    id: Int,
    summary: String,
    genres: List(Tag),
    tags: List(Tag),
    publication_status: Publication,
    series_id: Int,
    writers: List(Nil),
    cover_artists: List(Nil),
    publishers: List(Nil),
    characters: List(Nil),
    pencillers: List(Nil),
    inkers: List(Nil),
    imprints: List(Nil),
    colorists: List(Nil),
    letterers: List(Nil),
    editors: List(Nil),
    translators: List(Nil),
    teams: List(Nil),
    locations: List(Nil),
    age_rating: Int,
    release_year: Int,
    language: String,
    max_count: Int,
    total_count: Int,
    web_links: String,
    language_locked: Bool,
    summary_locked: Bool,
    age_rating_locked: Bool,
    publication_status_locked: Bool,
    genres_locked: Bool,
    tags_locked: Bool,
    writer_locked: Bool,
    character_locked: Bool,
    colorist_locked: Bool,
    editor_locked: Bool,
    inker_locked: Bool,
    imprint_locked: Bool,
    letterer_locked: Bool,
    penciller_locked: Bool,
    publisher_locked: Bool,
    translator_locked: Bool,
    team_locked: Bool,
    location_locked: Bool,
    cover_artist_locked: Bool,
    release_year_locked: Bool,
  )
}

pub fn metadata_decoder() {
  use id <- decode.field("id", decode.int)
  use genres <- decode.field("genres", decode.list(tag_decoder()))
  use tags <- decode.field("tags", decode.list(tag_decoder()))
  use summary <- decode.field("summary", decode.string)
  use publication_status <- decode.field(
    "publicationStatus",
    decode.new_primitive_decoder("Publication", dynamic_publication),
  )
  use series_id <- decode.field("seriesId", decode.int)
  use writers <- decode.field("writers", decode.success([]))
  use cover_artists <- decode.field("coverArtists", decode.success([]))
  use publishers <- decode.field("publishers", decode.success([]))
  use characters <- decode.field("characters", decode.success([]))
  use pencillers <- decode.field("pencillers", decode.success([]))
  use inkers <- decode.field("inkers", decode.success([]))
  use imprints <- decode.field("imprints", decode.success([]))
  use colorists <- decode.field("colorists", decode.success([]))
  use letterers <- decode.field("letterers", decode.success([]))
  use editors <- decode.field("editors", decode.success([]))
  use translators <- decode.field("translators", decode.success([]))
  use teams <- decode.field("teams", decode.success([]))
  use locations <- decode.field("locations", decode.success([]))
  use age_rating <- decode.field("ageRating", decode.int)
  use release_year <- decode.field("releaseYear", decode.int)
  use language <- decode.field("language", decode.string)
  use max_count <- decode.field("maxCount", decode.int)
  use total_count <- decode.field("totalCount", decode.int)
  use web_links <- decode.field("webLinks", decode.string)
  use language_locked <- decode.field("languageLocked", decode.bool)
  use summary_locked <- decode.field("summaryLocked", decode.bool)
  use age_rating_locked <- decode.field("ageRatingLocked", decode.bool)
  use publication_status_locked <- decode.field(
    "publicationStatusLocked",
    decode.bool,
  )
  use genres_locked <- decode.field("genresLocked", decode.bool)
  use tags_locked <- decode.field("tagsLocked", decode.bool)
  use writer_locked <- decode.field("writerLocked", decode.bool)
  use character_locked <- decode.field("characterLocked", decode.bool)
  use colorist_locked <- decode.field("coloristLocked", decode.bool)
  use editor_locked <- decode.field("editorLocked", decode.bool)
  use inker_locked <- decode.field("inkerLocked", decode.bool)
  use imprint_locked <- decode.field("imprintLocked", decode.bool)
  use letterer_locked <- decode.field("lettererLocked", decode.bool)
  use penciller_locked <- decode.field("pencillerLocked", decode.bool)
  use publisher_locked <- decode.field("publisherLocked", decode.bool)
  use translator_locked <- decode.field("translatorLocked", decode.bool)
  use team_locked <- decode.field("teamLocked", decode.bool)
  use location_locked <- decode.field("locationLocked", decode.bool)
  use cover_artist_locked <- decode.field("coverArtistLocked", decode.bool)
  use release_year_locked <- decode.field("releaseYearLocked", decode.bool)

  decode.success(Metadata(
    id:,
    genres:,
    tags:,
    summary:,
    publication_status:,
    series_id:,
    writers:,
    cover_artists:,
    publishers:,
    characters:,
    pencillers:,
    inkers:,
    imprints:,
    colorists:,
    letterers:,
    editors:,
    translators:,
    teams:,
    locations:,
    age_rating:,
    release_year:,
    language:,
    max_count:,
    total_count:,
    web_links:,
    language_locked:,
    summary_locked:,
    age_rating_locked:,
    publication_status_locked:,
    genres_locked:,
    tags_locked:,
    writer_locked:,
    character_locked:,
    colorist_locked:,
    editor_locked:,
    inker_locked:,
    imprint_locked:,
    letterer_locked:,
    penciller_locked:,
    publisher_locked:,
    translator_locked:,
    team_locked:,
    location_locked:,
    cover_artist_locked:,
    release_year_locked:,
  ))
}

pub fn metadata_to_json(metadata: Metadata) -> json.Json {
  json.object([
    #("id", json.int(metadata.id)),
    #("summary", json.string(metadata.summary)),
    #("genres", json.array(metadata.genres, of: tag_encoder)),
    #("tags", json.array(metadata.tags, of: tag_encoder)),
    #("seriesId", json.int(metadata.series_id)),
    #("writers", json.preprocessed_array([])),
    #("coverArtists", json.preprocessed_array([])),
    #("publishers", json.preprocessed_array([])),
    #("characters", json.preprocessed_array([])),
    #("pencillers", json.preprocessed_array([])),
    #("inkers", json.preprocessed_array([])),
    #("imprints", json.preprocessed_array([])),
    #("colorists", json.preprocessed_array([])),
    #("letterers", json.preprocessed_array([])),
    #("editors", json.preprocessed_array([])),
    #("translators", json.preprocessed_array([])),
    #("teams", json.preprocessed_array([])),
    #("locations", json.preprocessed_array([])),
    #("ageRating", json.int(metadata.age_rating)),
    #("releaseYear", json.int(metadata.release_year)),
    #("language", json.string(metadata.language)),
    #("maxCount", json.int(metadata.max_count)),
    #("totalCount", json.int(metadata.total_count)),
    #("webLinks", json.string(metadata.web_links)),
    #("languageLocked", json.bool(metadata.language_locked)),
    #("summaryLocked", json.bool(metadata.summary_locked)),
    #("ageRatingLocked", json.bool(metadata.age_rating_locked)),
    #("publicationStatus", publication_to_json(metadata.publication_status)),
    #("publicationStatusLocked", json.bool(metadata.publication_status_locked)),
    #("genresLocked", json.bool(metadata.genres_locked)),
    #("tagsLocked", json.bool(metadata.tags_locked)),
    #("writerLocked", json.bool(metadata.writer_locked)),
    #("characterLocked", json.bool(metadata.character_locked)),
    #("coloristLocked", json.bool(metadata.colorist_locked)),
    #("editorLocked", json.bool(metadata.editor_locked)),
    #("inkerLocked", json.bool(metadata.inker_locked)),
    #("imprintLocked", json.bool(metadata.imprint_locked)),
    #("lettererLocked", json.bool(metadata.letterer_locked)),
    #("pencillerLocked", json.bool(metadata.penciller_locked)),
    #("publisherLocked", json.bool(metadata.publisher_locked)),
    #("translatorLocked", json.bool(metadata.translator_locked)),
    #("teamLocked", json.bool(metadata.team_locked)),
    #("locationLocked", json.bool(metadata.location_locked)),
    #("coverArtistLocked", json.bool(metadata.cover_artist_locked)),
    #("releaseYearLocked", json.bool(metadata.release_year_locked)),
  ])
}

pub type Publication {
  Ongoing
  Hiatus
  Completed
  Cancelled
  Ended

  Unknown
  Invalid
}

fn publication_to_json(publication: Publication) -> json.Json {
  case publication {
    Ongoing -> json.int(0)
    Hiatus -> json.int(1)
    Completed -> json.int(2)
    Cancelled -> json.int(3)
    Ended -> json.int(4)
    _ -> json.int(0)
  }
}

fn dynamic_publication(
  from: dynamic.Dynamic,
) -> Result(Publication, Publication) {
  case decode.run(from, decode.int) {
    Ok(num) ->
      case num {
        // https://github.com/Kareadita/Kavita/blob/develop/API/Entities/Enums/PublicationStatus.cs
        0 -> Ok(Ongoing)
        1 -> Ok(Hiatus)
        2 -> Ok(Completed)
        3 -> Ok(Cancelled)
        4 -> Ok(Ended)
        _ -> Error(Unknown)
      }
    Error(_) -> Error(Invalid)
  }
}

pub fn publication_title(publication: Publication) -> String {
  case publication {
    Ongoing -> "ongoing"
    Hiatus -> "hiatus"
    Completed -> "completed"
    Cancelled -> "cancelled"
    Ended -> "ended"
    _ -> "unknown"
  }
}

pub type Tag {
  Tag(id: Int, title: String)
}

fn tag_decoder() {
  use id <- decode.field("id", decode.int)
  use title <- decode.field("title", decode.string)
  decode.success(Tag(id:, title:))
}

fn tag_encoder(t: Tag) -> json.Json {
  json.object([#("id", json.int(t.id)), #("title", json.string(t.title))])
}

pub fn date_decoder() {
  decode.new_primitive_decoder("Date", fn(v) {
    use timestamp <- result.try(
      decode.run(v, decode.string)
      |> result.map_error(fn(_) { date.new("May 19 2024") }),
    )
    Ok(date.new(timestamp))
  })
}

pub fn get(id: Int, resp: api.Response(Series, a)) {
  let decoder = {
    use id <- decode.field("id", decode.int)
    use name <- decode.field("name", decode.string)
    use localized_name <- decode.field("localizedName", decode.string)
    use created <- decode.field("created", date_decoder())
    use last_chapter_added <- decode.field("lastChapterAdded", date_decoder())
    use pages <- decode.field("pages", decode.int)
    use pages_read <- decode.field("pagesRead", decode.int)
    decode.success(Series(
      id:,
      name:,
      localized_name:,
      created:,
      last_chapter_added:,
      pages:,
      pages_read:,
      metadata: option.None,
    ))
  }

  let assert Ok(req) =
    request.to(api.create_url("/api/series/" <> int.to_string(id)))

  let req =
    req
    |> request.set_method(http.Get)
    |> request.set_body(json.object([]) |> json.to_string)
    |> request.set_header("Authorization", "Bearer " <> account.token())
    |> request.set_header("Accept", "application/json")
    |> request.set_header("Content-Type", "application/json")

  rsvp.send(req, rsvp.expect_json(decoder, resp))
}

pub fn metadata(id: Int, resp: api.Response(Metadata, a)) {
  let assert Ok(req) =
    request.to(api.create_url(
      "/api/series/metadata?seriesId=" <> int.to_string(id),
    ))

  let req =
    req
    |> request.set_method(http.Get)
    |> request.set_body(json.object([]) |> json.to_string)
    |> request.set_header("Authorization", "Bearer " <> account.token())
    |> request.set_header("Accept", "application/json")
    |> request.set_header("Content-Type", "application/json")

  rsvp.send(req, rsvp.expect_json(metadata_decoder(), resp))
}

pub fn update_metadata(metadata: Metadata, resp: api.Response(Nil, a)) {
  let assert Ok(req) = request.to(api.create_url("/api/series/metadata"))

  let req =
    req
    |> request.set_method(http.Post)
    |> request.set_body(
      json.object([#("seriesMetadata", metadata_to_json(metadata))])
      |> json.to_string,
    )
    |> request.set_header("Authorization", "Bearer " <> account.token())
    |> request.set_header("Accept", "application/json")
    |> request.set_header("Content-Type", "application/json")

  rsvp.send(req, api.expect_ok_response(resp))
}

pub fn tags(resp: api.Response(List(Tag), a)) {
  let assert Ok(req) = request.to(api.create_url("/api/metadata/tags"))

  let req =
    req
    |> request.set_method(http.Get)
    |> request.set_body(json.object([]) |> json.to_string)
    |> request.set_header("Authorization", "Bearer " <> account.token())
    |> request.set_header("Accept", "application/json")
    |> request.set_header("Content-Type", "application/json")

  rsvp.send(req, rsvp.expect_json(decode.list(tag_decoder()), resp))
}

pub fn details(series_id: Int, resp: api.Response(Details, a)) {
  let assert Ok(req) =
    request.to(api.create_url(
      "/api/series/series-detail?seriesId=" <> int.to_string(series_id),
    ))

  let req =
    req
    |> request.set_method(http.Get)
    |> request.set_body(json.object([]) |> json.to_string)
    |> request.set_header("Authorization", "Bearer " <> account.token())
    |> request.set_header("Accept", "application/json")
    |> request.set_header("Content-Type", "application/json")

  rsvp.send(req, rsvp.expect_json(details_decoder(), resp))
}
